// # ДЗ к лекции База#19

// ## Необходимо написать контейнерный тип Result

// У которого будет два состояния: Ok и Err.

// ```js
class Result {
  #state;
  #result;
  constructor(fn) {
    try {
      this.#result = fn();
      this.#state = "Ok";
    } catch (error) {
      this.#state = "Err";
      this.#result = error;
    }
  }
  isOk() {
    return this.#state === "Ok";
  }
  getValue() {
    if (this.isOk()) return this.#result;
  }
  getError() {
    if (!this.isOk()) return this.#result;
  }
  then(cb) {
    if (this.#state === "Ok") cb(this.#result);
    return this;
  }
  catch(cb) {
    if (this.#state === "Err") cb(this.#result);
    return this;
  }
}

// const res1 = new Result(() => 42);

// res1.then((data) => {
//   console.log(data);
// });

// const res2 = new Result(() => {
//   throw "Boom!";
// });

// res2
//   .then((data) => {
//     // Этот callback не вызовется
//     console.log(data);

//     // А этот вызовется
//   })
//   .catch(console.error);

// ```// ## Необходимо используя генераторы создать аналог async/await для контейнера Result

// ```js
const exec = (generator) => {
  const iterator = generator();
  let next = iterator.next();

  while (!next.done) {
    const result = next.value;

    if (result.isOk()) next = iterator.next(result.getValue());
    else next = iterator.throw(result.getError());
  }
  return next.value;
};

exec(function* main() {
  const res1 = new Result(() => 42);
  console.log(yield res1);

  try {
    const res2 = new Result(() => {
      throw "Boom!";
    });
    console.log(yield res2);
  } catch (err) {
    console.error("catched here", err);
  }
});
// ```;

// # Context from ChatGPT

// Основная идея в том, что yield сам по себе — это просто способ приостановить выполнение генератора и вернуть значение наружу. Он не выполняет никакой логики обработки ошибок или асинхронности сам по себе. Именно комбинация yield с функцией-исполнителем (в данном случае exec) позволяет нам эмулировать поведение async/await.

// Вот что мы добиваемся:

// Пауза и передача управления:
// Когда генератор доходит до выражения yield res1, он приостанавливается и возвращает контейнер (например, объект типа Result) наружу. Это похоже на то, как оператор await приостанавливает функцию, пока Promise не разрешится. Но yield сам не обрабатывает результат — он просто отдаёт его, и дальше уже внешняя функция (exec) решает, как его обработать.

// Контроль за продолжением выполнения:
// Функция exec анализирует контейнер (через методы isOk, getValue и т.д.) и в зависимости от состояния (Ok или Err) вызывает:

// iterator.next(value), если контейнер содержит корректное значение, или

// iterator.throw(error), если контейнер содержит ошибку.

// Таким образом, внутри генератора выражение yield res1 получает либо значение (как await возвращает результат), либо генерирует исключение (как await бросает ошибку). Это и делает код похожим на async/await.

// Явная обработка ошибок:
// Благодаря тому, что мы вручную вызываем либо next, либо throw, мы вынуждены явно обрабатывать оба сценария. Это даёт нам возможность использовать привычный синтаксис try/catch в генераторе для обработки ошибок асинхронных операций.

// Почему же без exec then/catch не сработали бы? Потому что:

// Наш контейнерный тип Result сам по себе — это просто объект с методами, он не запускает никакую логику «автоматически». Он не является настоящим Promise, у которого есть встроенная система микротасков и автоматическое разрешение.

// Если бы мы просто создали объект типа Result и не передали его в exec, то генератор получил бы этот объект как результат yield, но ничего бы не происходило: он не смог бы сам «решить», как извлечь значение или ошибку из него.

// Именно функция exec, вызывающая then/throw (в твоём случае через getValue() и проверку состояния), позволяет нам взять этот контейнер, определить его состояние и затем передать соответствующее значение обратно в генератор, тем самым эмулируя поведение async/await.

// Таким образом, полезность данного подхода в том, что мы можем писать код, который выглядит линейно (с использованием yield и try/catch), и при этом получать семантику асинхронного ожидания и обработки ошибок, как с async/await. Это учит нас тому, как устроена «магия» за синтаксисом async/await, и как можно самостоятельно организовать асинхронный поток управления с помощью генераторов.

// You said:
// Но ведь в Result нет ничего асинхронного

// ChatGPT said:
// Reasoned for 4 seconds
// Да, в твоем примере Result работает синхронно – он сразу возвращает значение или ошибку при создании. Но вот что важно:

// Единый интерфейс обработки результата.
// Используя контейнерный тип (Result), мы заставляем код явно различать успешное выполнение и ошибку, даже если операция синхронная. Это учит тебя думать о том, что любая операция может завершиться ошибкой, и её надо обработать.

// Подготовка к асинхронности.
// Несмотря на то, что сейчас Result синхронен, если в будущем ты захочешь сделать операцию асинхронной (например, обернуть сетевой запрос или чтение файла), можно будет сохранить тот же интерфейс – результат по-прежнему будет возвращаться в виде контейнера с состоянием Ok или Err. Тогда твой код, использующий генераторы (yield/exec), останется неизменным. Это значительно упрощает миграцию к асинхронному выполнению.

// Имитация async/await.
// Механизм с генераторами и exec показывает, как можно эмулировать поведение async/await. Даже если операция сейчас синхронная, логика передачи результата через yield (и его последующее «подхватывание» через iterator.next() или iterator.throw()) демонстрирует, как можно организовать поток управления при асинхронных операциях. Это помогает понять, как под капотом работает async/await, ведь тот же принцип – приостановка выполнения до получения результата – применяется и там.

// Итак, даже если в текущей реализации Result нет ничего асинхронного, сама структура позволяет:

// Разделять успешные и ошибочные результаты через один и тот же интерфейс,

// Писать код, похожий на асинхронный (с yield, try/catch),

// Легко расширять функциональность на асинхронные операции в будущем, не меняя API обработки ошибок.

// Это важный концептуальный шаг – понять, как можно абстрагироваться от синхронности конкретной операции и создать универсальный механизм обработки ошибок, который будет работать как для синхронных, так и для асинхронных задач.
